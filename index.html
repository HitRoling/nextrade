<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Offline File Manager PWA</title>
  <style>
    :root { --bg: #f2f2f2; --surface: #ffffff; --primary: #2563EA; --text: #2C3E50; --radius: 8px; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: var(--bg); font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; }
    h1 { color: var(--text); margin-bottom: 20px; }
    .uploader { background: var(--surface); padding: 15px; border-radius: var(--radius); width: 100%; max-width: 400px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
    input[type=file] { display: block; margin-bottom: 10px; }
    .files { margin-top: 10px; }
    .file-item { display: flex; justify-content: space-between; align-items: center; background: #fafafa; padding: 8px; border-radius: var(--radius); margin-bottom: 8px; }
    button { background: var(--primary); color: #fff; border: none; padding: 6px 12px; border-radius: var(--radius); cursor: pointer; }
    button.delete { background: #E74C3C; }
  </style>
</head>
<body>
  <h1>Offline File Manager</h1>
  <div class="uploader">
    <input type="file" id="fileInput" multiple>
    <div class="files" id="filesList"></div>
  </div>  <script>
    // IndexedDB helper
    const DB_NAME = 'offline-files-db';
    const STORE_NAME = 'files';
    let db;
    function openDB() {
      return new Promise((res, rej) => {
        const rq = indexedDB.open(DB_NAME, 1);
        rq.onupgradeneeded = () => {
          rq.result.createObjectStore(STORE_NAME, { keyPath: 'name' });
        };
        rq.onsuccess = () => res(rq.result);
        rq.onerror = () => rej(rq.error);
      });
    }
    async function addFile(file) {
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      return store.put({ name: file.name, data: file });
    }
    async function getAllFiles() {
      const tx = db.transaction(STORE_NAME, 'readonly');
      const store = tx.objectStore(STORE_NAME);
      return store.getAll();
    }
    async function deleteFile(name) {
      const tx = db.transaction(STORE_NAME, 'readwrite');
      tx.objectStore(STORE_NAME).delete(name);
      return tx.complete;
    }
    // UI
    const fileInput = document.getElementById('fileInput');
    const filesList = document.getElementById('filesList');
    fileInput.addEventListener('change', async () => {
      for (const file of fileInput.files) {
        await addFile(file);
      }
      fileInput.value = '';
      renderFiles();
    });
    async function renderFiles() {
      const all = await getAllFiles();
      filesList.innerHTML = '';
      all.forEach(item => {
        const div = document.createElement('div');
        div.className = 'file-item';
        const link = document.createElement('a');
        link.textContent = item.name;
        link.href = URL.createObjectURL(item.data);
        link.download = item.name;
        const btn = document.createElement('button');
        btn.textContent = 'Delete'; btn.className = 'delete';
        btn.onclick = async () => { await deleteFile(item.name); renderFiles(); };
        div.append(link, btn);
        filesList.append(div);
      });
    }
    // Initialize DB + render
    openDB().then(instance => { db = instance; renderFiles(); });

    // Inject manifest
    const manifest = { name:'Offline File Manager', short_name:'Files', start_url:'.', display:'standalone', background_color:'#f2f2f2', theme_color:'#2563EA' };
    const mBlob = new Blob([JSON.stringify(manifest)], { type:'application/json' });
    const mURL = URL.createObjectURL(mBlob);
    Object.assign(document.createElement('link'),{rel:'manifest',href:mURL}).before();

    // Service Worker as blob
    const swCode = `
      const C='offline-files-v1'; const U=['.'];
      self.addEventListener('install',e=>e.waitUntil(caches.open(C).then(c=>c.addAll(U)).then(()=>self.skipWaiting())));
      self.addEventListener('activate',e=>e.waitUntil(caches.keys().then(keys=>Promise.all(keys.map(k=>k!==C?caches.delete(k):0))).then(()=>self.clients.claim())));
      self.addEventListener('fetch',e=>e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request))));
    `;
    const swBlob = new Blob([swCode],{type:'application/javascript'});
    navigator.serviceWorker.register(URL.createObjectURL(swBlob)).catch(console.error);
  </script></body>
</html>
